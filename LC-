//LRU Cache
//Design and implement a data structure for Least Recently Used (LRU) cache. 
//It should support the following operations: get and set. 
// get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
// set(key, value) - Set or insert the value if the key is not already present. 
// When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. 


class LRUCache{
public:

struct DLinkItem {
        int key;
        int val;
        DLinkItem *prev;
        DLinkItem *next;
        DLinkItem(int k, int v) : key(k), val(v), prev(nullptr), next(nullptr) {}
    };
    
    LRUCache(int capacity) : maxCapacity(capacity),numItems(0),head(nullptr),tail(nullptr) {
    }
    
    int get(int key) {
        DLinkItem *item = cacheMap[key];
        if (item != nullptr) {
            return item->val;
        }
        return -1;
    }
    
    void set(int key, int value) {
        DLinkItem *item = cacheMap[key];
        if (item == nullptr) {
            if (numItems == maxCapacity) {
                DLinkItem *item = head;
                head = head->next;
                head->prev = nullptr;
                delete item;
                --numItems;
            }
            item = new DLinkItem(key,value);
            cacheMap[key] = item;
        } 
        if (item->prev) {
            item->prev->next = item->next;
        }
        if (item->next) {
            item->next->prev = item->prev;
        }
        if (tail == nullptr)
            tail = item;
        tail->next = item;
        item->prev = tail;
        tail = item;
        ++numItems;
    }
    
private:
    int maxCapacity;
    int numItems;
    DLinkItem *head;
    DLinkItem *tail;
    map<int,DLinkItem*> cacheMap;
};
